Что не так в этом коде? Перечислите, какие недостатки вы видите. Предложите свой вариант рефакторинга.
```cpp
#include <stdio.h>
class Feature
{
public:
    enum FeatureType {eUnknown, eCircle, eTriangle, eSquare};
    Feature() : type(eUnknown), points(0) {    }
    ~Feature()
    {
        if (points)
            delete points;
    }
    bool isValid() 
    {
        return type != eUnknown;
    }

    bool read(FILE* file)
    {        
        if (fread(&type, sizeof(FeatureType), 1, file) != sizeof(FeatureType))
            return false;
        short n = 0;
        switch (type) 
        {
        case eCircle: n = 3; break;
        case eTriangle:    n = 6; break;
        case eSquare: n = 8; break;
        default: type = eUnknown; return false;
        }
        points = new double[n];
        if (!points)
            return false;
        return fread(&points, sizeof(double), n, file) == n*sizeof(double);
    }
    void draw()
    {
        switch (type)
        {
        case eCircle: drawCircle(points[0], points[1], points[2]); break;
        case eTriangle:    drawPoligon(points, 6); break;
        case eSquare: drawPoligon(points, 8); break;
        }
    }

protected:
    void drawCircle(double centerX, double centerY, double radius);
    void drawPoligon(double* points, int size);
    double* points;
    FeatureType type;        

};

int main(int argc, char* argv[])
{
    Feature feature;
    FILE* file = fopen("features.dat", "r");
    feature.read(file);
    if (!feature.isValid())
        return 1;
    return 0;
}
```

Проблемы:
1. Нет определений функций drawCircle и drawPoligon. 
2. Метод isValid() проверяет только тип фигуры, что не гарантирует корректное выделение памяти и данных. 
3. Освобождение памяти от points нужно делать через delete[], поскольку это массив.
4. Вместо fread(&points, ...) должно быть fread(points, ...) в функции read(). Использование &points приведет к тому, что в файл будет записан адрес указателя, а не данные по этому адресу, так как points уже указатель.
5. В функции read в строке points = new double[n], происходит динамическое выделение памяти, но проверяется корректность выделения(исключение, нулевой указатель)
6. Переменная n не имеет осмысленного названия и инициализируется непонятными значениями.
7. Была вызвана функция fopen, но не вызвана fclose. Это может привести к некорректному обращению с ресурсами файла.
8. Возвращаемое значение функции в строке  feature.read(file); нигде не используется, оно может сообщить о неверно завершенном процессе чтения.

Рефакторинг:

Сделать класс Feature абстрактным. Каждый тип фигуры будет наследоваться от  Feature. Это позволит добавлять новые фигуры не изменяя код других классов. Также каждый класс-наследник будет хранить своё число вершин, что уберет из кода переменную n.
