Все ли хорошо в этом коде?
Файл legacy.c
```cpp
int values[3];
```

Файл modern.cpp
```cpp
#define LEGACY_SIZE 3

extern int *values;

class MyBlah {...};

class Adapter
{
public:
    Adapter()
    {
for (int i = 0; i < LEGACY_SIZE; ++i)
     map_[values[i]] = new MyBlah (values[i]);
    }
private:
    std::map<int, MyBlah *> map_;
};
```

1. В файле modern.cpp не прописано подключение файла legacy.c.
2. Массив int values3; не инициализирован, обращение к таким данным ведет к неопределённому поведению.
3. Для использования массива values из legacy.c, в файле modern.cpp перменная должна быть объявлена как extern int values3;. В данном коде int values является указателем.
4. Логичнее было бы определить макрос в файле legacy.c подставить его в объявлении массива values.
5. Не подключен заголовочный файл < map >, будет ошибка компиляции.
6. В классе Adapter используется оператор new, и не проверяется результат его работы. Может быть исключение или нулевой указатель.
 7. У класса Adapter не определён деструктор, следовательно создастся деструктор по умолчанию, который не освободит память, выделенную при создании new MyBlah (values[i]).
8. i объявлена как знаковый тип, и используется для итерирования по циклу, чтобы избежать предупреждения компилятора стоит использовать size_t
9. Если значения в  массиве values будут совпадать, то в строке map_[values[i]] = new MyBlah (values[i]); то указатель будет перезаписан новыми данными, и произойдет утечка памяти.

